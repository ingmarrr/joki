use crate::{ast::IntBase, err::LexError};

#[derive(Debug, PartialEq)]
pub enum TokKind {
    Ident,
    Comment,
    LitChar,
    LitString,
    LitInt,
    LitFloat,
    Alpha,
    Num,

    Plus,
    Minus,
    Star,
    Slash,
    Percent,

    Eq,
    Gt,
    Lt,

    Neq,
    Deq,
    Geq,
    Leq,
    AddEq,
    SubEq,
    MulEq,
    DivEq,
    Lsl,
    Lsr,
    And,
    Or,
    Caret,
    Wave,

    LParen,
    RParen,
    LSquare,
    RSquare,
    LBrace,
    RBrace,

    Colon,
    SemiColon,
    DoubleColon,
    RangeEx,
    RangeInc,
    Comma,
    Bang,
    Ques,
    At,
    Pound,
    Under,
    Dot,
    SQ,
    DQ,

    T,
    Type,
    Let,
    Fn,
    // Proc
    Asm,
    Struct,
    Trait,
    Comptime,
    Package,
    Pub,
    Mut,
    Use,

    If,
    Else,
    Match,
    Return,
    True,
    False,
    For,

    Ws,
    Nl,
    Tab,
    Invalid,
    Esc,
    EOF,
}

impl From<Tok> for TokKind {
    fn from(value: Tok) -> Self {
        match value {
            Tok::Ident(_) => TokKind::Ident,
            Tok::Comment(_) => TokKind::Comment,
            Tok::LitChar(_) => TokKind::LitChar,
            Tok::LitString { .. } => TokKind::LitString,
            Tok::LitFloat { .. } => TokKind::LitFloat,
            Tok::LitInt { .. } => TokKind::LitInt,
            Tok::Alpha(_) => TokKind::Alpha,
            Tok::Num(_) => TokKind::Num,

            Tok::Plus => TokKind::Plus,
            Tok::Minus => TokKind::Minus,
            Tok::Star => TokKind::Star,
            Tok::Slash => TokKind::Slash,
            Tok::Percent => TokKind::Percent,

            Tok::Eq => TokKind::Eq,
            Tok::Gt => TokKind::Gt,
            Tok::Lt => TokKind::Lt,

            Tok::Neq => TokKind::Neq,
            Tok::Deq => TokKind::Deq,
            Tok::Geq => TokKind::Geq,
            Tok::Leq => TokKind::Leq,
            Tok::AddEq => TokKind::AddEq,
            Tok::SubEq => TokKind::SubEq,
            Tok::MulEq => TokKind::MulEq,
            Tok::DivEq => TokKind::DivEq,
            Tok::Lsl => TokKind::Lsl,
            Tok::Lsr => TokKind::Lsr,
            Tok::And => TokKind::And,
            Tok::Or => TokKind::Or,
            Tok::Caret => TokKind::Caret,
            Tok::Tilde => TokKind::Wave,

            Tok::LParen => TokKind::LParen,
            Tok::RParen => TokKind::RParen,
            Tok::LSquare => TokKind::LSquare,
            Tok::RSquare => TokKind::RSquare,
            Tok::LBrace => TokKind::LBrace,
            Tok::RBrace => TokKind::RBrace,

            Tok::Colon => TokKind::Colon,
            Tok::SemiColon => TokKind::SemiColon,
            Tok::DoubleColon => TokKind::DoubleColon,
            Tok::RangeEx => TokKind::RangeEx,
            Tok::RangeInc => TokKind::RangeInc,
            Tok::Comma => TokKind::Comma,
            Tok::Bang => TokKind::Bang,
            Tok::Ques => TokKind::Ques,
            Tok::At => TokKind::At,
            Tok::Pound => TokKind::Pound,
            Tok::Under => TokKind::Under,
            Tok::Dot => TokKind::Dot,
            Tok::SQ => TokKind::SQ,
            Tok::DQ => TokKind::DQ,

            Tok::T => TokKind::T,
            Tok::Type => TokKind::Type,
            Tok::Let => TokKind::Let,
            Tok::Fn => TokKind::Fn,
            // Proc
            Tok::Asm => TokKind::Asm,
            Tok::Struct => TokKind::Struct,
            Tok::Trait => TokKind::Trait,
            Tok::Comptime => TokKind::Comptime,
            Tok::Package => TokKind::Package,
            Tok::Pub => TokKind::Pub,
            Tok::Mut => TokKind::Mut,
            Tok::Use => TokKind::Use,

            Tok::If => TokKind::If,
            Tok::Else => TokKind::Else,
            Tok::Match => TokKind::Match,
            Tok::Return => TokKind::Return,
            Tok::True => TokKind::True,
            Tok::False => TokKind::False,
            Tok::For => TokKind::For,

            Tok::Ws => TokKind::Ws,
            Tok::Tab => TokKind::Tab,
            Tok::Nl => TokKind::Nl,
            Tok::Invalid => TokKind::Invalid,
            Tok::Esc => TokKind::Esc,
            Tok::EOF => TokKind::EOF,
        }
    }
}

#[derive(Debug, PartialEq)]
pub enum Tok {
    Ident(String),
    Comment(String),
    LitChar(char),
    LitString {
        buf: String,
        size: usize,
    },
    LitInt {
        buf: String,
        size: usize,
        base: IntBase,
    },
    LitFloat {
        buf: String,
        size: usize,
    },
    Alpha(char),
    Num(char),

    Plus,
    Minus,
    Star,
    Slash,
    Percent,

    Eq,
    Gt,
    Lt,

    Neq,
    Deq,
    Geq,
    Leq,
    AddEq,
    SubEq,
    MulEq,
    DivEq,
    Lsl,
    Lsr,
    And,
    Or,
    Caret,
    Tilde,

    LParen,
    RParen,
    LSquare,
    RSquare,
    LBrace,
    RBrace,

    Colon,
    SemiColon,
    DoubleColon,
    RangeEx,
    RangeInc,
    Comma,
    Bang,
    Ques,
    At,
    Pound,
    Under,
    Dot,
    SQ,
    DQ,

    T,
    Type,
    Let,
    Fn,
    // Proc
    Asm,
    Struct,
    Trait,
    Comptime,
    Package,
    Pub,
    Mut,
    Use,

    If,
    Else,
    Match,
    Return,
    True,
    False,
    For,

    Ws,
    Nl,
    Tab,
    Invalid,
    Esc,
    EOF,
}

impl From<char> for Tok {
    fn from(value: char) -> Self {
        match value {
            '+' => Tok::Plus,
            '-' => Tok::Minus,
            '*' => Tok::Star,
            '/' => Tok::Slash,
            '%' => Tok::Percent,
            '(' => Tok::LParen,
            ')' => Tok::RParen,
            '[' => Tok::LSquare,
            ']' => Tok::RSquare,
            '{' => Tok::LBrace,
            '}' => Tok::RBrace,
            ';' => Tok::SemiColon,
            ':' => Tok::Colon,
            ',' => Tok::Comma,
            '=' => Tok::Eq,
            '>' => Tok::Gt,
            '<' => Tok::Lt,
            '&' => Tok::And,
            '|' => Tok::Or,
            '^' => Tok::Caret,
            '~' => Tok::Tilde,
            '!' => Tok::Bang,
            '@' => Tok::At,
            '#' => Tok::Pound,
            '?' => Tok::Ques,
            '_' => Tok::Under,
            '.' => Tok::Dot,
            '\'' => Tok::SQ,
            '"' => Tok::DQ,
            '\\' => Tok::Esc,
            '\n' => Tok::Nl,
            '\r' => Tok::Nl,
            ' ' => Tok::Ws,
            '\t' => Tok::Tab,
            '\0' => Tok::EOF,
            _ if value.is_alphabetic() => Tok::Alpha(value),
            _ if value.is_numeric() => Tok::Num(value),
            _ => Tok::Invalid,
        }
    }
}

impl From<&str> for Tok {
    fn from(value: &str) -> Self {
        match value {
            "T" => Tok::T,
            "type" => Tok::Type,
            "let" => Tok::Let,
            "fn" => Tok::Fn,
            "asm" => Tok::Asm,
            "struct" => Tok::Struct,
            "trait" => Tok::Trait,
            "comp" => Tok::Comptime,
            "pub" => Tok::Pub,
            "pack" => Tok::Package,
            "mut" => Tok::Mut,
            "use" => Tok::Use,
            "if" => Tok::If,
            "else" => Tok::Else,
            "match" => Tok::Match,
            "return" => Tok::Return,
            "true" => Tok::True,
            "false" => Tok::False,
            "for" => Tok::For,
            "+=" => Tok::AddEq,
            "-=" => Tok::SubEq,
            "*=" => Tok::MulEq,
            "/=" => Tok::DivEq,
            "==" => Tok::Deq,
            "!=" => Tok::Neq,
            ">=" => Tok::Geq,
            "<=" => Tok::Leq,
            "<<" => Tok::Lsl,
            ">>" => Tok::Lsr,
            "//" => Tok::Comment("".into()),
            "::" => Tok::DoubleColon,
            ".." => Tok::RangeEx,
            "..=" => Tok::RangeInc,
            _ => Tok::Ident(value.to_string()),
        }
    }
}

impl std::fmt::Display for Tok {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Tok::Ident(s) => write!(f, "{}", s),
            Tok::LitString { buf: text, size } => write!(f, r#""{}" :: {}"#, text, size),
            Tok::LitChar(s) => write!(f, "'{}'", s),
            Tok::LitInt {
                buf: text,
                size,
                base: radix,
            } => write!(f, "{} :: {} :: {}", text, size, radix),
            Tok::LitFloat { buf: text, size } => write!(f, "{} :: {}", text, size),
            Tok::Alpha(c) => write!(f, "{}", c),
            Tok::Num(c) => write!(f, "{}", c),
            Tok::Plus => write!(f, "+"),
            Tok::Minus => write!(f, "-"),
            Tok::Star => write!(f, "*"),
            Tok::Slash => write!(f, "/"),
            Tok::Percent => write!(f, "%"),
            Tok::Eq => write!(f, "="),
            Tok::Gt => write!(f, ">"),
            Tok::Lt => write!(f, "<"),
            Tok::Neq => write!(f, "!="),
            Tok::Deq => write!(f, "=="),
            Tok::Geq => write!(f, ">="),
            Tok::Leq => write!(f, "<="),
            Tok::AddEq => write!(f, "+="),
            Tok::SubEq => write!(f, "-="),
            Tok::MulEq => write!(f, "*="),
            Tok::DivEq => write!(f, "/="),
            Tok::Lsl => write!(f, "<<"),
            Tok::Lsr => write!(f, ">>"),
            Tok::And => write!(f, "&"),
            Tok::Or => write!(f, "|"),
            Tok::Caret => write!(f, "^"),
            Tok::Tilde => write!(f, "~"),
            Tok::LParen => write!(f, "("),
            Tok::RParen => write!(f, ")"),
            Tok::LSquare => write!(f, "["),
            Tok::RSquare => write!(f, "]"),
            Tok::LBrace => write!(f, "{{"),
            Tok::RBrace => write!(f, "}}"),
            Tok::Colon => write!(f, ":"),
            Tok::SemiColon => write!(f, ";"),
            Tok::DoubleColon => write!(f, "::"),
            Tok::RangeEx => write!(f, ".."),
            Tok::RangeInc => write!(f, "..="),
            Tok::Comma => write!(f, ","),
            Tok::Bang => write!(f, "!"),
            Tok::Ques => write!(f, "?"),
            Tok::At => write!(f, "@"),
            Tok::Pound => write!(f, "#"),
            Tok::Under => write!(f, "_"),
            Tok::Dot => write!(f, "."),
            Tok::SQ => write!(f, "'"),
            Tok::DQ => write!(f, "\""),
            Tok::T => write!(f, "T"),
            Tok::Type => write!(f, "type"),
            Tok::Let => write!(f, "let"),
            Tok::Fn => write!(f, "fn"),
            Tok::Asm => write!(f, "asm"),
            Tok::Struct => write!(f, "struct"),
            Tok::Trait => write!(f, "trait"),
            Tok::Comptime => write!(f, "comp"),
            Tok::Package => write!(f, "pack"),
            Tok::Pub => write!(f, "pub"),
            Tok::Mut => write!(f, "mut"),
            Tok::Use => write!(f, "use"),
            Tok::If => write!(f, "if"),
            Tok::Else => write!(f, "else"),
            Tok::Match => write!(f, "match"),
            Tok::Return => write!(f, "return"),
            Tok::True => write!(f, "true"),
            Tok::False => write!(f, "false"),
            Tok::For => write!(f, "for"),
            Tok::Ws => write!(f, " "),
            Tok::Tab => write!(f, "\t"),
            Tok::Nl => write!(f, "\n"),
            Tok::Invalid => write!(f, "Invalid"),
            Tok::Esc => write!(f, "\\"),
            Tok::EOF => write!(f, "EOF"),
            Tok::Comment(s) => write!(f, "// {}", s),
        }
    }
}

pub enum InitTok {
    Plus,
    Minus,
    Star,
    Slash,
    Eq,
    Bang,
    Gt,
    Lt,
    Colon,
    Dot,
    Under,
    SQ,
    DQ,

    Alpha,
    Num,
}

impl TryFrom<char> for InitTok {
    type Error = Tok;

    fn try_from(value: char) -> Result<Self, Self::Error> {
        match value {
            '+' => Ok(InitTok::Plus),
            '-' => Ok(InitTok::Minus),
            '*' => Ok(InitTok::Star),
            '/' => Ok(InitTok::Slash),
            '=' => Ok(InitTok::Eq),
            '!' => Ok(InitTok::Bang),
            '>' => Ok(InitTok::Gt),
            '<' => Ok(InitTok::Lt),
            '\'' => Ok(InitTok::SQ),
            '"' => Ok(InitTok::DQ),
            '_' => Ok(InitTok::Under),
            '.' => Ok(InitTok::Dot),
            _ if value.is_alphabetic() => Ok(InitTok::Alpha),
            _ if value.is_numeric() => Ok(InitTok::Num),
            _ => Err(Tok::from(value)),
        }
    }
}

impl TryFrom<Tok> for InitTok {
    type Error = Tok;

    fn try_from(value: Tok) -> Result<Self, Self::Error> {
        match value {
            Tok::Plus => Ok(InitTok::Plus),
            Tok::Minus => Ok(InitTok::Minus),
            Tok::Star => Ok(InitTok::Star),
            Tok::Slash => Ok(InitTok::Slash),
            Tok::Eq => Ok(InitTok::Eq),
            Tok::Bang => Ok(InitTok::Bang),
            Tok::Gt => Ok(InitTok::Gt),
            Tok::Lt => Ok(InitTok::Lt),
            Tok::SQ => Ok(InitTok::SQ),
            Tok::DQ => Ok(InitTok::DQ),
            Tok::Dot => Ok(InitTok::Dot),
            Tok::Alpha(_) => Ok(InitTok::Alpha),
            Tok::Num(_) => Ok(InitTok::Num),
            Tok::Under => Ok(InitTok::Under),
            _ => Err(value),
        }
    }
}

impl TryFrom<&Tok> for InitTok {
    type Error = LexError;

    fn try_from(value: &Tok) -> Result<Self, Self::Error> {
        match value {
            Tok::Plus => Ok(InitTok::Plus),
            Tok::Minus => Ok(InitTok::Minus),
            Tok::Star => Ok(InitTok::Star),
            Tok::Slash => Ok(InitTok::Slash),
            Tok::Eq => Ok(InitTok::Eq),
            Tok::Bang => Ok(InitTok::Bang),
            Tok::Gt => Ok(InitTok::Gt),
            Tok::Lt => Ok(InitTok::Lt),
            Tok::SQ => Ok(InitTok::SQ),
            Tok::DQ => Ok(InitTok::DQ),
            Tok::Dot => Ok(InitTok::Dot),
            Tok::Alpha(_) => Ok(InitTok::Alpha),
            Tok::Num(_) => Ok(InitTok::Num),
            Tok::Under => Ok(InitTok::Under),
            _ => Err(LexError::NotInit(value.to_string())),
        }
    }
}
